import hre from 'hardhat';
import { expect } from 'chai';
import { deployFactoryFixture } from '../fixtures';
import { Gateway, Gateway__factory } from '../../../types';
import {
  DeployContractOptions,
  HardhatEthersHelpers as HardhatEthersHelpersBase,
} from '@nomicfoundation/hardhat-ethers/types';
import { ethers } from 'ethers';

const GATEWAY_FQN = 'contracts/identity/gateway/Gateway.sol:Gateway';

//Extends autogenerated types to support fully qualified names
declare module 'hardhat/types/runtime' {
  interface HardhatEthersHelpers extends HardhatEthersHelpersBase {
    deployContract(
      name: 'contracts/identity/gateway/Gateway.sol:Gateway',
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions,
    ): Promise<Gateway>;
  }
}

/*
  This is also working:

  const factory = new Gateway__factory().connect(deployerWallet);
  const gateway = await factory.deploy(idFactoryContractAddress, [carolWallet.address]);

*/

describe('Gateway', () => {
  describe('constructor', () => {
    describe('when factory address is not specified', () => {
      it('should revert', async () => {
        await expect(hre.ethers.deployContract(GATEWAY_FQN, [hre.ethers.ZeroAddress, []])).to.be.reverted;
      });
    });

    describe('when specifying more than 10 signer', () => {
      it('should revert', async () => {
        const { idFactoryContract, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();

        await expect(
          hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, Array(11).fill(hre.ethers.ZeroAddress)]),
        ).to.be.reverted;
      });
    });
  });

  describe('.deployIdentityWithSalt()', () => {
    describe('when input address is the zero address', () => {
      it('should revert', async () => {
        const { idFactoryContract, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        await expect(
          gateway.deployIdentityWithSalt(
            hre.ethers.ZeroAddress,
            'saltToUse',
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            hre.ethers.randomBytes(65),
          ),
        ).to.be.reverted;
      });
    });

    describe('when signature is not valid', () => {
      it('should revert with UnsignedDeployment', async () => {
        const { idFactoryContract, aliceWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);

        await expect(
          gateway.deployIdentityWithSalt(
            aliceWallet.address,
            'saltToUse',
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            hre.ethers.randomBytes(65),
          ),
        ).to.be.reverted;
      });
    });

    describe('when signature is signed by a non authorized signer', () => {
      it('should revert with UnsignedDeployment', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);

        await expect(
          gateway.deployIdentityWithSalt(
            aliceWallet.address,
            'saltToUse',
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            await bobWallet.signMessage(
              hre.ethers.keccak256(
                hre.ethers.AbiCoder.defaultAbiCoder().encode(
                  ['string', 'address', 'string', 'uint256'],
                  [
                    'Authorize ONCHAINID deployment',
                    aliceWallet.address,
                    'saltToUse',
                    BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
                  ],
                ),
              ),
            ),
          ),
        ).to.be.revertedWithCustomError(gateway, 'UnapprovedSigner');
      });
    });

    describe('when signature is correct and signed by an authorized signer', () => {
      it('should deploy the identity', async () => {
        const { idFactoryContract, aliceWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        const tx = await gateway.deployIdentityWithSalt(
          aliceWallet.address,
          'saltToUse',
          BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
          signature,
        );
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });

    describe('when signature is correct with no expiry', () => {
      it('should deploy the identity', async () => {
        const { idFactoryContract, aliceWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            ['Authorize ONCHAINID deployment', aliceWallet.address, 'saltToUse', 0],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        const tx = await gateway.deployIdentityWithSalt(aliceWallet.address, 'saltToUse', 0, signature);
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });

    describe('when signature is correct and signed by an authorized signer, but revoked', () => {
      it('should revert', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        await gateway.revokeSignature(signature);

        await expect(
          gateway.deployIdentityWithSalt(
            aliceWallet.address,
            'saltToUse',
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            signature,
          ),
        ).to.be.revertedWithCustomError(gateway, 'RevokedSignature');
      });
    });

    describe('when signature is correct and signed by an authorized signer, but has expired', () => {
      it('should revert', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n - BigInt(2 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        await gateway.revokeSignature(signature);

        await expect(
          gateway.deployIdentityWithSalt(
            aliceWallet.address,
            'saltToUse',
            BigInt(new Date().getTime()) / 1000n - BigInt(2 * 24 * 60 * 60),
            signature,
          ),
        ).to.be.revertedWithCustomError(gateway, 'ExpiredSignature');
      });
    });
  });

  describe('.deployIdentityWithSaltAndManagementKeys', () => {
    describe('when input address is the zero address', () => {
      it('should revert', async () => {
        const { idFactoryContract, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);

        await expect(
          gateway.deployIdentityWithSaltAndManagementKeys(
            hre.ethers.ZeroAddress,
            'saltToUse',
            [],
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            hre.ethers.randomBytes(65),
          ),
        ).to.be.reverted;
      });
    });

    describe('when signature is not valid', () => {
      it('should revert with UnsignedDeployment', async () => {
        const { idFactoryContract, aliceWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);

        await expect(
          gateway.deployIdentityWithSaltAndManagementKeys(
            aliceWallet.address,
            'saltToUse',
            [],
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            hre.ethers.randomBytes(65),
          ),
        ).to.be.reverted;
      });
    });

    describe('when signature is signed by a non authorized signer', () => {
      it('should revert with UnsignedDeployment', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);

        await expect(
          gateway.deployIdentityWithSaltAndManagementKeys(
            aliceWallet.address,
            'saltToUse',
            [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            await bobWallet.signMessage(
              hre.ethers.keccak256(
                hre.ethers.AbiCoder.defaultAbiCoder().encode(
                  ['string', 'address', 'string', 'bytes32[]', 'uint256'],
                  [
                    'Authorize ONCHAINID deployment',
                    aliceWallet.address,
                    'saltToUse',
                    [
                      hre.ethers.keccak256(
                        hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]),
                      ),
                    ],
                    BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
                  ],
                ),
              ),
            ),
          ),
        ).to.be.revertedWithCustomError(gateway, 'UnapprovedSigner');
      });
    });

    describe('when signature is correct and signed by an authorized signer', () => {
      it('should deploy the identity', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'bytes32[]', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        const tx = await gateway.deployIdentityWithSaltAndManagementKeys(
          aliceWallet.address,
          'saltToUse',
          [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
          BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
          signature,
        );
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.false;
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });

    describe('when signature is correct with no expiry', () => {
      it('should deploy the identity', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'bytes32[]', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
              0,
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        const tx = await gateway.deployIdentityWithSaltAndManagementKeys(
          aliceWallet.address,
          'saltToUse',
          [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
          0,
          signature,
        );
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.false;
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });

    describe('when signature is correct and signed by an authorized signer, but revoked', () => {
      it('should revert', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'bytes32[]', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        await gateway.revokeSignature(signature);

        await expect(
          gateway.deployIdentityWithSaltAndManagementKeys(
            aliceWallet.address,
            'saltToUse',
            [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
            BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            signature,
          ),
        ).to.be.revertedWithCustomError(gateway, 'RevokedSignature');
      });
    });

    describe('when signature is correct and signed by an authorized signer, but has expired', () => {
      it('should revert', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);

        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'bytes32[]', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
              BigInt(new Date().getTime()) / 1000n - BigInt(2 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));

        await gateway.revokeSignature(signature);

        await expect(
          gateway.deployIdentityWithSaltAndManagementKeys(
            aliceWallet.address,
            'saltToUse',
            [hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [bobWallet.address]))],
            BigInt(new Date().getTime()) / 1000n - BigInt(2 * 24 * 60 * 60),
            signature,
          ),
        ).to.be.revertedWithCustomError(gateway, 'ExpiredSignature');
      });
    });
  });

  describe('deployIdentityForWallet', () => {
    describe('when input address is the zero address', () => {
      it('should revert', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.deployIdentityForWallet(hre.ethers.ZeroAddress)).to.revertedWithCustomError(
          gateway,
          'ZeroAddress',
        );
      });
    });
    describe('when sender is not the desired identity owner', () => {
      it('should deploy the identity for the identity owner', async () => {
        const [deployerWallet] = await hre.ethers.getSigners();
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        // see comments at the top of the file
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const tx = await gateway.connect(bobWallet).deployIdentityForWallet(aliceWallet.address);
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });
    describe('when an identity was not yet deployed for this walet', () => {
      it('should deploy the identity', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const tx = await gateway.connect(aliceWallet).deployIdentityForWallet(aliceWallet.address);
        await expect(tx)
          .to.emit(idFactoryContract, 'WalletLinked')
          .withArgs(aliceWallet.address, await idFactoryContract.getIdentity(aliceWallet.address));
        await expect(tx)
          .to.emit(idFactoryContract, 'Deployed')
          .withArgs(await idFactoryContract.getIdentity(aliceWallet.address));
        const identityAddress = await idFactoryContract.getIdentity(aliceWallet.address);
        const identity = await hre.ethers.getContractAt('Identity', identityAddress);
        expect(
          await identity.keyHasPurpose(
            hre.ethers.keccak256(hre.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [aliceWallet.address])),
            1,
          ),
        ).to.be.true;
      });
    });
    describe('when an identity was already deployed for this wallet as salt with the factory', () => {
      it('should revert because factory reverts', async () => {
        const { idFactoryContract, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await gateway.connect(aliceWallet).deployIdentityForWallet(aliceWallet.address);
        await expect(gateway.connect(aliceWallet).deployIdentityForWallet(aliceWallet.address)).to.be.revertedWith(
          'salt already taken',
        );
      });
    });
  });

  describe('.transferFactoryOwnership', () => {
    describe('when called by the owner', () => {
      it('should transfer ownership of the factory to the specified address', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.transferFactoryOwnership(bobWallet.address))
          .to.emit(idFactoryContract, 'OwnershipTransferred')
          .withArgs(gatewayAddress, bobWallet.address);
        expect(await idFactoryContract.owner()).to.be.equal(bobWallet.address);
      });
    });
    describe('when not called by the owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(
          gateway.connect(aliceWallet).transferFactoryOwnership(bobWallet.address),
        ).to.be.revertedWithCustomError(gateway, 'OwnableUnauthorizedAccount');
      });
    });
  });

  describe('.revokeSignature', () => {
    describe('when calling not as owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));
        await expect(gateway.connect(aliceWallet).revokeSignature(signature)).to.be.revertedWithCustomError(
          gateway,
          'OwnableUnauthorizedAccount',
        );
      });
    });
    describe('when signature was already revoked', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));
        await gateway.revokeSignature(signature);
        await expect(gateway.revokeSignature(signature)).to.be.revertedWithCustomError(
          gateway,
          'SignatureAlreadyRevoked',
        );
      });
    });
  });

  describe('.approveSignature', () => {
    describe('when calling not as owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));
        await expect(gateway.connect(aliceWallet).approveSignature(signature)).to.be.revertedWithCustomError(
          gateway,
          'OwnableUnauthorizedAccount',
        );
      });
    });
    describe('when signature is not revoked', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));
        await expect(gateway.approveSignature(signature)).to.be.revertedWithCustomError(gateway, 'SignatureNotRevoked');
      });
    });
    describe('when signature is revoked', () => {
      it('should approve the signature', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const digest = hre.ethers.keccak256(
          hre.ethers.AbiCoder.defaultAbiCoder().encode(
            ['string', 'address', 'string', 'uint256'],
            [
              'Authorize ONCHAINID deployment',
              aliceWallet.address,
              'saltToUse',
              BigInt(new Date().getTime()) / 1000n + BigInt(365 * 24 * 60 * 60),
            ],
          ),
        );
        const signature = await carolWallet.signMessage(hre.ethers.getBytes(digest));
        await gateway.revokeSignature(signature);
        const tx = await gateway.approveSignature(signature);
        expect(tx).to.emit(gateway, 'SignatureApproved').withArgs(signature);
      });
    });
  });

  describe('.approveSigner', () => {
    describe('when signer address is zero', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.approveSigner(hre.ethers.ZeroAddress)).to.be.revertedWithCustomError(
          gateway,
          'ZeroAddress',
        );
      });
    });
    describe('when calling not as owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.connect(aliceWallet).approveSigner(bobWallet.address)).to.be.revertedWithCustomError(
          gateway,
          'OwnableUnauthorizedAccount',
        );
      });
    });
    describe('when signer is already approved', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await gateway.approveSigner(bobWallet.address);
        await expect(gateway.approveSigner(bobWallet.address)).to.be.revertedWithCustomError(
          gateway,
          'SignerAlreadyApproved',
        );
      });
    });
    describe('when signer is not approved', () => {
      it('should approve the signer', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [carolWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const tx = await gateway.approveSigner(bobWallet.address);
        expect(tx).to.emit(gateway, 'SignerApproved').withArgs(bobWallet.address);
      });
    });
  });
  describe('.revokeSigner', () => {
    describe('when signer address is zero', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [aliceWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.revokeSigner(hre.ethers.ZeroAddress)).to.be.revertedWithCustomError(
          gateway,
          'ZeroAddress',
        );
      });
    });
    describe('when calling not as owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [bobWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.connect(aliceWallet).revokeSigner(bobWallet.address)).to.be.revertedWithCustomError(
          gateway,
          'OwnableUnauthorizedAccount',
        );
      });
    });
    describe('when signer is not approved', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [aliceWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(gateway.revokeSigner(bobWallet.address)).to.be.revertedWithCustomError(
          gateway,
          'SignerAlreadyNotApproved',
        );
      });
    });
    describe('when signer is approved', () => {
      it('should revoke the signer', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [bobWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const tx = await gateway.revokeSigner(bobWallet.address);
        expect(tx).to.emit(gateway, 'SignerRevoked').withArgs(bobWallet.address);
      });
    });
  });

  describe('.callFactory', () => {
    describe('when not calling as the owner', () => {
      it('should revert', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [aliceWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(
          gateway
            .connect(aliceWallet)
            .callFactory(
              new hre.ethers.Interface(['function addTokenFactory(address)']).encodeFunctionData('addTokenFactory', [
                hre.ethers.ZeroAddress,
              ]),
            ),
        ).to.be.revertedWithCustomError(gateway, 'OwnableUnauthorizedAccount');
      });
    });
    describe('when calling as the owner with invalid parameters', () => {
      it('should revert for Factory error', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet, carolWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [aliceWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        await expect(
          gateway
            .connect(deployerWallet)
            .callFactory(
              new hre.ethers.Interface(['function addTokenFactory(address)']).encodeFunctionData('addTokenFactory', [
                hre.ethers.ZeroAddress,
              ]),
            ),
        ).to.be.revertedWith('Gateway: call to factory failed');
      });
    });
    describe('when calling as the owner with correct parameters', () => {
      it('should execute the function call', async () => {
        const { idFactoryContract, deployerWallet, aliceWallet, bobWallet } = await deployFactoryFixture();
        const idFactoryContractAddress = await idFactoryContract.getAddress();
        const gateway = await hre.ethers.deployContract(GATEWAY_FQN, [idFactoryContractAddress, [aliceWallet.address]]);
        const gatewayAddress = await gateway.getAddress();
        await idFactoryContract.transferOwnership(gatewayAddress);
        const tx = await gateway
          .connect(deployerWallet)
          .callFactory(
            new hre.ethers.Interface(['function addTokenFactory(address)']).encodeFunctionData('addTokenFactory', [
              bobWallet.address,
            ]),
          );
        expect(tx).to.emit(idFactoryContract, 'TokenFactoryAdded').withArgs(bobWallet.address);
      });
    });
  });
});
